# Subagent Logging Specification

## Status
Draft

## Motivation
CPE supports **subagents** via MCP server mode (`cpe mcp serve`). Today, when a parent CPE session invokes a subagent (which is exposed to the parent as an MCP tool), the parent does **not** receive real-time visibility into what the subagent is doing.

The only currently reliable options are:

- wait until the subagent finishes and inspect the MCP tool result (often only the final assistant message or the `final_answer` payload)
- inspect `.cpeconvo` conversation storage after the fact

This is insufficient for observability and control:

- users cannot tell *what the subagent is doing right now*
- users cannot decide to cancel early based on intermediate behavior
- failures or runaway code-mode executions are only visible at the end

The goal of this spec is to provide **real-time streaming of subagent execution blocks** (tool calls, tool results, and thought traces) to the *root* CPE process so it can print them for the user.

## Goals

- Print subagent **tool calls**, **tool results**, and **thought traces** in real time.
- Reuse the **exact same rendering/formatting** as the existing generator printers.
- Prefix each printed header with the **subagent name** so interleaved output remains understandable.
- Work across **arbitrary depth** of subagent recursion (subagents can invoke subagents).
- Work when subagents use **code mode** (where tools run inside a Go harness subprocess).
- Require **no changes** to external MCP clients.

## Non-goals

- Provide a general-purpose, standards-based MCP notification/logging stream (MCP logging is insufficient for code mode; see Constraints).
- Provide a stable public network API; the transport is internal and localhost-only.
- Persist events (persistence remains `.cpeconvo` and/or `.cpe.log`).

## Background / Constraints

### Stdio discipline in MCP server mode
MCP server mode uses stdio transport, and **stdout is reserved for MCP protocol bytes**. Any human-readable output on stdout can corrupt the protocol stream.

Therefore, subagent progress cannot be printed directly from the subagent server process to stdout.

### Code mode swallows MCP logs/events
When code mode is enabled, tools are executed by compiling/running a separate Go program (`go run` in a temp directory). That subprocess creates fresh MCP sessions and calls MCP tools.

Any MCP protocol notifications/logging emitted during tool execution are confined to that subprocess and are not a reliable channel back to the root CPE process.

This eliminates architectures that rely on MCP logging notifications.

## User-facing Output Requirements

Subagent blocks should be printed **exactly the same way** as existing generator output (see `internal/agent/response_printer.go` and `internal/agent/tool_result_printer.go`), with one difference: the header is prefixed with the subagent name.

### Tool call header
Generator (existing):

```markdown
#### [tool call] (timeout: 10s)
```

Subagent (new):

```markdown
#### code-review-agent [tool call] (timeout: 10s)
```

### Tool result header
Same as generator tool result formatting, but header prefixed with subagent name. Example (conceptual):

```markdown
#### code-review-agent Tool "shell" result:
```

### Thought trace header
When rendering thinking blocks from subagents, print a dedicated header:

```markdown
#### code-review-agent thought trace
```

Then print the thinking content using the existing thinking renderer.

### Avoid duplicated "final" output
A subagent is an MCP tool from the parent perspective.

- The parent will print the **tool result** returned by that MCP tool.
- That tool result corresponds to either:
  - the subagent's final assistant text, or
  - the subagent's `final_answer` structured output

To avoid duplicates, the root printer MUST NOT additionally print the subagent's final assistant block.

Additionally, if the subagent calls the `final_answer` tool, we should not print that tool call as a normal tool call block (or otherwise duplicate the final payload). The parent will see the tool result.

## Architecture Overview

## Subagent MCP Tool Input Schema

To support end-to-end correlation, the subagent MCP tool MUST require a parent-provided run identifier.

Tool input arguments:

- `prompt` (string, required)
- `inputs` (string[], optional)
- `runId` (string, required) — generated by the invoking parent

The server should reject tool calls that omit `runId`.


### High-level idea
The root CPE process creates a local HTTP server used exclusively for **subagent event streaming**.

- The root process chooses an unused localhost port.
- The root process injects an environment variable into MCP server processes:

```
CPE_SUBAGENT_LOGGING_ADDRESS=http://127.0.0.1:<port>
```

- Any CPE process (server, subagent server, code-mode harness) that sees this env var will POST subagent event blocks to that address.
- The root CPE process prints blocks to **stderr** as it receives them.

This works for arbitrary depth because environment variables are inherited by child processes.

### When to inject

The invoking parent must pass a required `runId` argument when calling the subagent MCP tool. This `runId` becomes the `subagentRunID` used for all emitted events.
Inject `CPE_SUBAGENT_LOGGING_ADDRESS` when:

- CPE is running in normal CLI mode (root)
- CPE is acting as an MCP client starting MCP servers (including CPE subagent servers)

Do NOT inject when:

- CPE is itself running as an MCP server (to avoid recursive local servers, unless explicitly desired)

### Transport requirements

- localhost only
- fail-fast: if a subagent cannot publish an event to the logging address, abort the subagent execution with an error
- safe under concurrency (multiple subagents can run in parallel)

## Event Model

### Event types
We only need to stream the same conceptual "blocks" that the response printer handles:

- tool call block
- tool result block
- thought trace (thinking) block

Additionally, it is useful to include lifecycle events:

- subagent start
- subagent end

### Minimal event schema
All events include:

- `subagentName` (string)
- `subagentRunID` (string) — **mandatory**, supplied by the invoking parent tool call
- `timestamp` (RFC3339 or unix millis)
- `type` (enum)

The `subagentRunID` MUST be generated by the parent (invoker) and passed to the subagent tool call, so the entire execution tree can correlate events under a single stable run identifier.

For content events:

- `tokenUsage` (object, optional) — token accounting metadata for the generating model call when available
  - `inputTokens` (int, optional)
  - `outputTokens` (int, optional)
  - `totalTokens` (int, optional)
  - `cacheReadTokens` (int, optional)
  - `cacheWriteTokens` (int, optional)

- `toolName` (string) — for tool call/result
- `toolCallID` (string) — if available
- `payload` (string) — raw JSON arguments or raw tool output (already truncated if needed)
- `executionTimeoutSeconds` (int) — only for execute_go_code tool call if available
- `reasoningType` (string) — for thought trace (e.g. `reasoning.encrypted`)

Note: payload should be sent in a way that preserves exact formatting expectations (e.g. pretty-printed JSON where appropriate).

### Ordering
Each printed block must be written atomically (single write to stderr) so concurrent subagent output may interleave by block but never interleave within a block.

Token usage is best-effort and model/provider dependent. If the underlying generator does not provide usage metadata for a given chunk/turn, omit `tokenUsage`. Note this does not affect the fail-fast requirement for event publishing itself.

Events are sent as they occur. Output may interleave between subagents. The subagent name prefix is the mechanism that keeps output understandable.

## HTTP API

### Failure semantics

Event publishing is part of the subagent execution contract for this feature.

If a CPE process running a subagent has `CPE_SUBAGENT_LOGGING_ADDRESS` set and fails to POST an event (connection refused, non-2xx response, timeout, etc.), it MUST treat this as a fatal error and abort the subagent run.

Rationale: if we cannot emit events, observability is broken and something is seriously wrong (misconfiguration, unexpected process topology, or root logger crashed).


### Endpoint

- `POST /subagent-events`

### Request body
A JSON object representing one event.

Example:

```json
{
  "subagentName": "code-review-agent",
  "subagentRunID": "a1b2c3d4",
  "type": "tool_call",
  "toolName": "execute_go_code",
  "toolCallID": "call_123",
  "executionTimeoutSeconds": 10,
  "tokenUsage": { "inputTokens": 1234, "outputTokens": 456, "totalTokens": 1690 },
  "payload": "package main...",
  "timestamp": "2026-01-23T00:00:00Z"
}
```

### Response
- `200 OK` on success
- errors should not cause the subagent run to fail; clients should drop/log errors

## Printing / Rendering

### Reuse existing printers
The root process should reuse existing formatting logic:

- tool call formatting from `internal/agent/response_printer.go`
- tool result formatting from `internal/agent/tool_result_printer.go`

The only change is **prefixing headers** with the subagent name.

### Header prefix rules

- Tool call:
  - from: `#### [tool call] ...`
  - to:   `#### <subagentName> [tool call] ...`

- Tool result:
  - from: `#### Tool "X" result:`
  - to:   `#### <subagentName> Tool "X" result:`

- Code mode result:
  - from: `#### Code execution output:`
  - to:   `#### <subagentName> Code execution output:`

- Thought trace:
  - new header: `#### <subagentName> thought trace`

### Skipping rules

- Do not print the subagent's final assistant message block (it will appear as the MCP tool result in the parent).
- Do not print the `final_answer` tool call block.

## Integration Points

### Root process: HTTP server
The root process starts the HTTP server early (before spawning MCP servers).

Responsibilities:

- listen on localhost with random port
- accept `POST /subagent-events`
- immediately render to stderr
- include subagent name prefix

### MCP client: inject env var into spawned servers
Wherever CPE spawns MCP servers (stdio command transport), it should append `CPE_SUBAGENT_LOGGING_ADDRESS` to the child process environment.

### MCP server: emit events
When CPE runs as MCP server (`cpe mcp serve`), wrap the generator so that tool calls/results and thinking blocks are emitted as events.

### Code mode: preserve env
The generated Go harness uses `os.Environ()` when launching stdio MCP servers, which naturally preserves the env var.

No special code mode changes are required: even when a subagent is invoked from code mode as an MCP tool call (via the generated Go functions), the subagent is still executed by a CPE MCP server process that will emit events to `CPE_SUBAGENT_LOGGING_ADDRESS`.

## Testing Strategy

- Unit tests for header prefix formatting (tool call, tool result, code execution output).
- Integration test: parent CPE starts subagent server with env var injection, triggers a subagent run, and asserts events are received.
- Code mode integration test: subagent calls `execute_go_code` which calls an MCP tool; ensure subagent events still reach root.

## Design Decisions

The following questions were considered and resolved:

- **Batching:** No batching. Events are sent and printed immediately as they occur. Real-time visibility is the priority.
- **Backpressure:** Not needed. Subagent event volume is extremely low (a few events per second at most). Over-engineering.
- **Authentication:** None. The HTTP server is localhost-only and short-lived. No authentication is required.
- **Payload formatting:** The sender transmits compact JSON. The receiver (root process) is responsible for pretty-printing when rendering to stderr.
